#!/bin/bash
set -e
set -u

. ci/functions.sh

usage() {
  cat <<EOF
  Usage: $(basename $0) [-dh] [-v level]
    -d          debug, shorthand for -v2
    -h          help (this screen)
    -v level    verbosity, where level is 0, 1, or 2
EOF
}

# http://wiki.bash-hackers.org/howto/getopts_tutorial
while getopts ":dhv:" opt; do
  case ${opt} in
    d)
      verbosity=2
      ;;
    h)
      usage
      exit 0
      ;;
    v)
      verbosity=${OPTARG}
      ;;
    \:)
      usage
      err option -${OPTARG} requires an argument
      exit 1
      ;;
    \?|*)
      usage
      err invalid option -${OPTARG}
      exit 1
      ;;
  esac
done

# After the shift, $* contains non-option arguments.
shift $((OPTIND-1))

is_binary() {
  file="$1"
  code=1
  file --mime "${file}" | grep 'binary$' &> /dev/null && code=0 || :
  return ${code}
}

is_shell_script() {
  file="$1"
  code=1
  file --mime "${file}" | grep 'shellscript' &> /dev/null && code=0 || :
  [[ "${file}" =~ .sh$ ]] && code=0 || :
  return ${code}
}

check_binary() {
  file="$1"
  if [[ "${file}" =~ assets/ ]]; then
    : # Binaries are allowed in the assets directory.
  elif [[ $(stat --printf=%s "${file}") -eq 0 ]]; then
    : # Zero-sized files are not binary.
  elif $(is_binary "${file}"); then
    err \"${file}\" is a binary file
    return 1
  fi
}

check_shell_syntax() {
  file="$1"
  if $(is_shell_script "${file}"); then
    bash -n "${file}"
  fi
}

check_whitespace() {
  file="$1"
  if $(is_binary "${file}"); then
    : # Binary files can have trailing whitespace.
  elif grep -E '\s$' "${file}"; then
    err \"${file}\" has trailing whitespace
    return 1
  fi
}

# https://github.com/koalaman/shellcheck/wiki/SC2044
code=0
while IFS= read -r -d '' file; do
  debug checking "${file}"
  check_binary "${file}"        || code=1
  check_shell_syntax "${file}"  || code=1
  check_whitespace "${file}"    || code=1
done < <(git ls-files -z)

exit ${code}
